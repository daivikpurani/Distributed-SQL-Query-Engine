# Project Notes - Distributed SQL Query Engine

## Design Goals

This project was created to simulate a simplified distributed query processing system that demonstrates:

- **Query Parsing and Planning**: Converting SQL into executable plans
- **Parallel Execution**: Distributing work across multiple worker nodes
- **Fault Tolerance**: Handling failures through checkpointing and retries
- **Instrumentation**: Tracing and monitoring query execution
- **gRPC Communication**: High-performance RPC between components

## System Architecture

### Component Overview

**Coordinator (Port 50051)**
- Central orchestrator that receives client queries
- Parses SQL using simple regex-based parser
- Creates execution plans using rule-based planner
- Distributes tasks to worker nodes
- Aggregates results and returns to client

**Worker Nodes (Ports 50052-50054)**
- Execute query plan nodes on partitioned data
- Handle fault tolerance through checkpointing
- Simulate failures for testing purposes
- Return partial results to coordinator

**Client**
- CLI interface for submitting queries
- Displays results in tabular format
- Shows query execution plans and statistics

### Communication Flow

1. Client → Coordinator: SQL query via gRPC
2. Coordinator: Parse SQL → Create plan → Distribute tasks
3. Coordinator → Workers: Task requests via gRPC
4. Workers: Execute tasks → Create checkpoints → Return results
5. Coordinator: Aggregate results → Return to client

## Query Lifecycle

### 1. Query Parsing
- Simple regex-based SQL parser
- Supports SELECT, WHERE, JOIN operations
- Converts SQL to structured Query object
- Handles basic operators: =, !=, >, <, >=, <=

### 2. Query Planning
- Rule-based planner (not cost-based)
- Creates execution plan tree with nodes:
  - SCAN: Table access operations
  - FILTER: WHERE condition application
  - PROJECT: Column selection
  - JOIN: Table join operations
- Estimates row counts for planning
- Assigns tasks to available workers

### 3. Task Execution
- Coordinator breaks plan into worker tasks
- Workers execute plan nodes on partitioned data
- Parallel execution across multiple workers
- Results aggregated at coordinator

### 4. Result Processing
- Workers return partial results
- Coordinator merges results from all workers
- Final result set returned to client

## Query Planning Logic

### Plan Node Types
- **SCAN**: Reads data from tables (users, orders)
- **FILTER**: Applies WHERE conditions
- **PROJECT**: Selects specific columns
- **JOIN**: Combines data from multiple tables

### Planning Strategy
- Bottom-up plan construction
- Single table queries: SCAN → FILTER → PROJECT
- Join queries: SCAN(left) + SCAN(right) → JOIN → FILTER → PROJECT
- Worker assignment based on data partitioning

### Data Partitioning
- Each worker gets subset of table data
- Simple round-robin partitioning simulation
- Workers process their partition independently
- Results merged at coordinator

## Fault Tolerance Mechanism

### Checkpointing
- Workers save partial execution state
- Checkpoints include intermediate results
- Enables recovery from mid-execution failures
- Stored in memory (not persisted to disk)

### Retry Logic
- Failed tasks retried on different workers
- Simulated failures for testing (10% probability)
- Network delay simulation
- Graceful error handling

### Failure Simulation
- Random failure injection for testing
- Network delay simulation
- Worker health monitoring
- Status reporting to coordinator

## Instrumentation and Tracing

### Query Tracing
- Complete lifecycle tracking per query
- Events: START → PARSE → PLAN → EXECUTE → COMPLETE
- Timing information for each phase
- JSON-formatted trace output

### Performance Metrics
- Query execution time
- Worker task duration
- Planning time
- Network communication timing

### Logging Strategy
- Structured logging with SLF4J
- Query lifecycle events
- Worker status updates
- Error tracking and debugging

## Key Learning Objectives

### Distributed Systems Concepts
- **Query Planning**: Converting SQL to distributed execution plans
- **Task Distribution**: Breaking work across multiple nodes
- **Result Aggregation**: Combining partial results
- **Fault Tolerance**: Handling failures gracefully

### gRPC and RPC Patterns
- **Service Definition**: Protocol buffer schemas
- **Client-Server Communication**: Blocking and async patterns
- **Error Handling**: gRPC status codes and exceptions
- **Connection Management**: Channel lifecycle

### Data Processing
- **Data Partitioning**: Distributing data across workers
- **Parallel Execution**: Concurrent task processing
- **Join Algorithms**: Simple nested loop joins
- **Filtering**: Condition evaluation

### Monitoring and Observability
- **Tracing**: Request lifecycle tracking
- **Metrics**: Performance measurement
- **Logging**: Structured event logging
- **Health Checks**: Service availability monitoring

## Technical Implementation Details

### Protocol Buffers
- Defined in `query.proto`
- Services: CoordinatorService, WorkerService
- Messages: QueryRequest, TaskRequest, ResultSet
- Enums: QueryStatus, TaskStatus, NodeType

### Data Models
- **Query**: Parsed SQL representation
- **PlanNode**: Execution plan tree nodes
- **ResultSet**: Query execution results
- **Row**: Individual data rows
- **Condition**: WHERE clause conditions

### Error Handling
- Custom exceptions for different failure modes
- Graceful degradation when workers fail
- Retry mechanisms with exponential backoff
- Comprehensive error logging

## Future Improvements

### Query Optimization
- **Cost-Based Optimizer**: Statistics-driven planning
- **Join Ordering**: Optimal join sequence selection
- **Index Usage**: Leverage indexes for performance
- **Predicate Pushdown**: Move filters closer to data

### Advanced Features
- **GROUP BY**: Aggregation operations
- **ORDER BY**: Sorting and ranking
- **LIMIT**: Result set size limiting
- **Subqueries**: Nested query support

### Scalability Enhancements
- **Dynamic Worker Registration**: Add/remove workers at runtime
- **Load Balancing**: Distribute work based on worker capacity
- **Data Shuffling**: Implement shuffle operations for joins
- **Caching**: Query result caching

### Production Readiness
- **Persistence**: Disk-based checkpointing
- **Security**: Authentication and authorization
- **Configuration**: External configuration management
- **Monitoring**: Metrics collection and alerting

## Testing Strategy

### Unit Testing
- Individual component testing
- Mock external dependencies
- Edge case validation

### Integration Testing
- End-to-end query execution
- Multi-worker scenarios
- Failure injection testing

### Performance Testing
- Query execution timing
- Memory usage monitoring
- Scalability testing

## Deployment Considerations

### Local Development
- Single-machine simulation
- Multiple JVM processes
- Port-based service discovery

### Production Deployment
- Container-based deployment
- Service mesh integration
- Load balancer configuration
- Monitoring and alerting

This project serves as a comprehensive demonstration of distributed SQL query processing concepts, providing hands-on experience with the challenges and solutions in building scalable data processing systems.
